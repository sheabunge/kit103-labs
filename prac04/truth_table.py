"""
For KIT103/KMA115 Practical 4: Logic
Revised: 2015-07-11
Author: James Montgomery (james.montgomery@utas.edu.au)

The truth_table function can generate truth tables given a predicate
and the number of variables that predicate works with. Also includes a
helper function eval_predicate which returns a list corresponding to
the last column in the truth table (useful for comparing the outcomes
of two different predicates).

The module also includes one correct and one broken implementation of
an 'implies' operator, as in p --> q.
"""

from itertools import product
from string import ascii_lowercase as names


def truth_table(p, n, binary=False):
	"""Draws the truth table for the given predicate of n parameters.

	For instance, given a predicate defined as
	def pred(a, b, c):
		return a and b and not c
	create the truth table with truth_table(pred, 3).

	Set the paramter 'binary' to True to display the truth table as
	zeroes and ones instead of Falses and Trues.\
	"""
	display_func = str if not binary else (lambda t: '1' if t else '0')
	sep = '  ' if binary else '\t'  # use compact display with 0 and 1 outputs
	inputs = product([False, True], repeat=n)
	print(sep.join(names[:n]) + sep + '| p')
	print('-' * (len(sep) + 1 if binary else 8) * (n + 1))
	for t in inputs:
		print(sep.join(map(display_func, t)) + sep + '| ' + display_func(p(*t)))


def eval_predicate(p, n):
	"""Evaluates the predicate of n parameters over all possible
	inputs and returns a list of the outcomes. Equivalent (in content)
	to the last column generated by truth_table(). You are not
	expected to understand the code below.
	"""
	return [p(*i) for i in product([False, True], repeat=n)]


def implies(p, q):
	"""Returns the result of p implies q, i.e., p --> q."""
	return not p or q


def naive_implies(p, q):
	"""p --> q naively implemented assuming that 'if p then q' is the same."""
	if p:
		return q


def truth_table_explained(p, n, binary=False):
	"""The truth_table function with each part explained in detail.
	This is only for those who are interested
	"""
	# These two lines determine how values of True and False will be displayed,
	# either as True and False or 1 and 0
	display_func = str if not binary else (lambda t: '1' if t else '0')
	sep = '  ' if binary else '\t'  # use compact display with 0 and 1 outputs

	# product() returns a generator the produces the elements of the Cartesian
	# product over one or multiple different sets
	# see https://docs.python.org/3/library/itertools.html#itertools.product
	inputs = product([False, True], repeat=n)

	# ascii_lowercase (from the string module), and imported with the shorter
	# identifier 'names', is a string of lowercase alphabetic characters
	# see https://docs.python.org/3/library/string.html#string.ascii_lowercase
	# the [:n] selects a slice of the string from the start to the character at
	# position n-1
	# see https://docs.python.org/3/tutorial/introduction.html#strings
	# join concatenates each element of an iterable with the string sep between them
	# see https://docs.python.org/3/library/stdtypes.html?highlight=join#str.join
	print(sep.join(names[:n]) + sep + '| p')

	# 'multiplying' a string by an integer concatenates the string with iteself that many times
	print('-' * (len(sep) + 1 if binary else 8) * (n + 1))

	for t in inputs:
		# Since t is a tuple, but p is a function that takes n arguments we need to 'unpack' these from the tuple: *t does this unpacking.
		# see https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists
		# join needs an iterable collection of strings, but since boolean values are not strings we need to convert them all.
		# The map function applies another function (in this case str) to every element of an iterable and returns a list of the results
		# see https://docs.python.org/2/library/functions.html#map
		print(sep.join(map(display_func, t)) + sep + '| ' + display_func(p(*t)))
